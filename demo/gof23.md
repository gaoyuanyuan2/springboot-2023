# 设计模式

## 单例


1、私有化构造器
2、保证线程安全
3、延迟加载
4、 防止序列化和反序列化破坏单例
5、 防御反射攻击单例

## 原型

原型模式(Prototype Pattern)是指原型实例指定创建对象的 种类，并且通过拷贝这些原型创建新的对象。

调用者不需要知道任何创建细节，不调用构造函数。

属于创建型模式

## 装饰器

### 装饰器模式和代理模式对比

1、装饰器模式就是种特殊的代理模式。
2、装饰器模式强调自身的功能扩展，用自己说了算的透明扩展，可动态定制的扩展。
3、代理模式强调代理过程的控制。


### 装饰器模式的优点

1、装饰器是继承的有力补充，比继承灵活，不改变原有对象的情况下动态地给一个对象扩展功能，即插即用。
2、通过使用不同装饰类以及这些装饰类的排列组合，可实现不同效果。
3、装饰器完全遵守开闭原则。

## 享元模式

### 享元模式的优点

减少对象的创建，降低内存中对象的数量，降低系统的内存，提高效率
减少内存之外的其他资源占用

### 享元模式的缺点

关注内、外部状态、关注线程安全问题
使系统、程序的逻辑复杂化

## 组合模式

### 组合模式的适用场景

1、希望客户端可以忽略组合对象与单个对象的差异时;
2、对象层次具备整体和部分，呈树形结构(如树形菜单，操作系统目 录结构，公司组织架构等)

### 组合模式的优点

1、清楚地定义分层次的复杂对象，表示对象的全部或部分层次
2、让客户端忽略了层次的差异，方便对整个层次结构进行控制
3、简化客户端代码
4、符合开闭原则

### 组合模式的缺点

1、 限制类型时会较为复杂
2、使设计变得更加抽象

## 模板模式

### 模板模式的优点

1、利用模板方法将相同处理逻辑的代码放到抽象父类中，可以提高代 码的复用性。
2、将不同的代码不同的子类中，通过对子类的扩展增加新的行为，提高代码的扩展性。
3、把不变的行为写在父类上，去除子类的重复代码，提供了一个很好 的代码复用平台，符合开闭原则。

### 模板模式的缺点

1、类数目的增加，每一个抽象类都需要一 个子类来实现，这样导致类的个数增加。
2、类数量的增加，间接地增加了系统实现的复杂度。
3、继承关系自身缺点，如果父类添加新的抽象方法，所有子类都要改 一遍。

## 策略模式

### 策略模式的适用场景

1、假如系统中有很多类，而他们的区别仅仅在于他们的行为不同
2、一个系统需要动态地在几种算法中选择一种。
3、需要屏蔽算法规则。

### 策略模式的优点

1、策略模式符合开闭原则。
2、避免使用多重条件转移语句，如if... else...语句、switch语句
3、使用策略模式可以提高算法的保密性和安全性。

### 策略模式的缺点

1、客户端必须知道所有的策略，并且自行决定使用哪一个策略类。
2、代码中会产生非常多策略类，增加维护难度。

### 举例

排序策略

Spring `org.springframework.core.io.Resource` 

`org.springframework.beans.factory.support.InstantiationStrategy`


## 责任链模式

### 责任链模式的定义

责任链模式(Chain of Responsibility Pattern) 是将链中每一个节 点看作是一个对象， 每个节点处理的请求均不同，且内部自动维护一 个下一节点对象。当一个请求从链式的首端发出时，会沿着链的路径 依次传递给每一个节点对象，直至有对象处理这个请求为止。
属于行为型模式。


### 责任链模式的适用场景

1、多个对象可以处理同一请求，但具体由哪个对象处理则在运行时动 态决定;
2、在不明确指定接收者的情况下，向多个对象中的一个提交一个请求;
3、可动态指定一-组对象处理请求。

### 责任链模式的优点

1、将请求与处理解耦;
2、请求处理者(节点对象)只需关注自己感兴趣的请求进行处理即可， 对于不感兴趣的请求，直接转发给下一级节点对象;
3、具备链式传递处理请求功能，请求发送者无需知晓链路结构，只需 等待请求处理结果;
4、链路结构灵活，可以通过改变链路结构动态地新增或删减责任;
5、易于扩展新的请求处理类(节点)，符合开闭原则。

### 责任链模式的缺点

1、责任链太长或者处理时间过长，会影响整体性能
2、如果节点对象存在循环引用时，会造成死循环，导致系统崩溃;

### 迭代器模式
### 迭代器模式的定义

迭代器模式(Iterator Pattern) 又称为游标模式(Cursor Pattern 它提供种顺序访问集 合/容器对象元素的方法， 而又无须暴露 集合部表示。

本质:抽离集合对象迭代行为到迭代器中，提供一致访问接口。
属于行为型模式。

### 迭代器模式的适用场景

1、访问一个集合对象的内容而无需暴露它的内部表示
2、为遍历不同的集合结构提供个统一的访问接口

### 迭代器模式的优点
1、多态迭代:为不同的聚合结构提供一致的遍历接口，即一个迭代接口可以访问不同的聚集对象;
2、简化集合对象接口:迭代器模式将集合对象本身应该提供的元素迭代接口抽取到了迭代器中，使集合对象无须关心具体迭代行为;
3、元素迭代功能多样化:每个集合对象都可以提供个或多个不同的迭代器，使的同种元素聚合结构可以有不同的迭代行为;
4、解耦迭代与集合:迭代器模式封装了具体的迭代算法，迭代算法 的变化，不会影响到集合对象的架构。

### 迭代器模式的缺点

1、对于比较简单的遍历(像数组或者有序列表)，使用迭代器方式遍历较为繁琐。

## 命令模式

### 命令模式的定义

命令模式(Command Pattern) 是对命令的封装，每一个命令都是个
操作:请求的一方发出请求要求执行一个操作;接收的一方收到请求， 并执行操作。命令模式解耦了请求方和接收方，请求方只需请求执行 命令，不用关心命令是怎样被接收，怎样被操作以及是否被执行...等。

本质:解耦命令请求与处理。

属于行为型模式。

遥控器
点菜单

### 命令模式的适用场景

1、现实语义中具备“命令”的操作(如命令菜单，shell命令...) ;
2、请求调用者和请求的接收者需要解耦，使得调用者和接收者不直接交互;
3、需要抽象出等待执行的行为，比如撤销(Undo)操作和恢复(Redo)等 操作;
4、需要支持命令宏(即命令组合操作)。


### 命令模式的优点

1、 通过引入中间件 (抽象接口)，解耦了 命令请求与实现;
2、扩展性良好，可以很容易地增加新命令;
3、支持组合命令，支持命令队列;
4、 可以在现有 命令的基础上，增加额外功能 (比如日志记录结合装饰器模式更酸爽)。


### 命令模式的缺点

1、具体命令类可能过多;
2、增加了程序的复杂度，理解更加困难。

## 备忘录模式

### 备忘录模式的定义

备忘录模式(Memento Pattern) 又称为快照模式(Snapshot Pattern)
或令牌模式(Token Pattern) ，是指在不破坏封装的前提下，捕获一 个对象的内部状态，井在对象之外保存这个状态。这样以后就可将该 对象恢复到原先保存的状态。

特征:“后悔药”

属于行为型模式

### 备忘录模式的优点

1、简化发起人实体类(Originator) 职责，隔离状态存储与获取，实 现了信息的封装，客户端无需关心状态的保存细节;
2、提供状态回滚功能;

### 备忘录模式的缺点

1、消耗资源:如果需要保存的状态过多时，每一次保存都会消耗很多 内存。

## 状态模式
### 状态模式的定义

状态模式(State Pattern) 也称为状态机模式(State Machine Pattern),是允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。

属于行为模式。

### 状态模式的适用场景

1、行为随状态改变而改变的场景;
2、一个操作中含有庞大的多分支结构，并且这些分支取决于对象的状态。

### 状态模式的优点

1、结构清晰:将状态独立为类，消除了冗余的if... else或 switch. .. case语句，使代码更加简洁，提高系统可维护性;
2、将状态转换显示化:通常的对象内部都是使用数值类型来定义状态， 状态的切换是通过赋值进行表现，不够直观;而使用状态类，在切换 状态时，是以不同的类进行表示，转换目的更加明确;
3、状态类职责明确且具备扩展性。

### 状态模式的缺点

1、 类膨胀: 如果一个事物具 备很多状态，则会造成状态类太多;
2、状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱;
3、状态模式对开闭原则的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态，而且修改某个状态类的行为也需修改对应类的源代码。

