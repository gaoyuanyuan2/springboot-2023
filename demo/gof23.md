# 设计模式

## 单例


1、私有化构造器
2、保证线程安全
3、延迟加载
4、 防止序列化和反序列化破坏单例
5、 防御反射攻击单例

## 原型

原型模式(Prototype Pattern)是指原型实例指定创建对象的 种类，并且通过拷贝这些原型创建新的对象。

调用者不需要知道任何创建细节，不调用构造函数。

属于创建型模式

## 装饰器

### 装饰器模式和代理模式对比

1、装饰器模式就是种特殊的代理模式。
2、装饰器模式强调自身的功能扩展，用自己说了算的透明扩展，可动态定制的扩展。
3、代理模式强调代理过程的控制。


### 装饰器模式的优点

1、装饰器是继承的有力补充，比继承灵活，不改变原有对象的情况下动态地给一个对象扩展功能，即插即用。
2、通过使用不同装饰类以及这些装饰类的排列组合，可实现不同效果。
3、装饰器完全遵守开闭原则。

## 享元模式

### 享元模式的优点

减少对象的创建，降低内存中对象的数量，降低系统的内存，提高效率
减少内存之外的其他资源占用

### 享元模式的缺点

关注内、外部状态、关注线程安全问题
使系统、程序的逻辑复杂化

## 组合模式

### 组合模式的适用场景

1、希望客户端可以忽略组合对象与单个对象的差异时;
2、对象层次具备整体和部分，呈树形结构(如树形菜单，操作系统目 录结构，公司组织架构等)

### 组合模式的优点

1、清楚地定义分层次的复杂对象，表示对象的全部或部分层次
2、让客户端忽略了层次的差异，方便对整个层次结构进行控制
3、简化客户端代码
4、符合开闭原则

### 组合模式的缺点

1、 限制类型时会较为复杂
2、使设计变得更加抽象

## 模板模式

### 模板模式的优点

1、利用模板方法将相同处理逻辑的代码放到抽象父类中，可以提高代 码的复用性。
2、将不同的代码不同的子类中，通过对子类的扩展增加新的行为，提高代码的扩展性。
3、把不变的行为写在父类上，去除子类的重复代码，提供了一个很好 的代码复用平台，符合开闭原则。

### 模板模式的缺点

1、类数目的增加，每一个抽象类都需要一 个子类来实现，这样导致类的个数增加。
2、类数量的增加，间接地增加了系统实现的复杂度。
3、继承关系自身缺点，如果父类添加新的抽象方法，所有子类都要改 一遍。

## 策略模式

### 策略模式的适用场景

1、假如系统中有很多类，而他们的区别仅仅在于他们的行为不同
2、一个系统需要动态地在几种算法中选择一种。
3、需要屏蔽算法规则。

### 策略模式的优点

1、策略模式符合开闭原则。
2、避免使用多重条件转移语句，如if... else...语句、switch语句
3、使用策略模式可以提高算法的保密性和安全性。

### 策略模式的缺点

1、客户端必须知道所有的策略，并且自行决定使用哪一个策略类。
2、代码中会产生非常多策略类，增加维护难度。

### 举例

排序策略

Spring `org.springframework.core.io.Resource` 

`org.springframework.beans.factory.support.InstantiationStrategy`


## 责任链模式

### 责任链模式的定义

责任链模式(Chain of Responsibility Pattern) 是将链中每一个节 点看作是一个对象， 每个节点处理的请求均不同，且内部自动维护一 个下一节点对象。当一个请求从链式的首端发出时，会沿着链的路径 依次传递给每一个节点对象，直至有对象处理这个请求为止。
属于行为型模式。


### 责任链模式的适用场景

1、多个对象可以处理同一请求，但具体由哪个对象处理则在运行时动 态决定;
2、在不明确指定接收者的情况下，向多个对象中的一个提交一个请求;
3、可动态指定一-组对象处理请求。

### 责任链模式的优点

1、将请求与处理解耦;
2、请求处理者(节点对象)只需关注自己感兴趣的请求进行处理即可， 对于不感兴趣的请求，直接转发给下一级节点对象;
3、具备链式传递处理请求功能，请求发送者无需知晓链路结构，只需 等待请求处理结果;
4、链路结构灵活，可以通过改变链路结构动态地新增或删减责任;
5、易于扩展新的请求处理类(节点)，符合开闭原则。

### 责任链模式的缺点

1、责任链太长或者处理时间过长，会影响整体性能
2、如果节点对象存在循环引用时，会造成死循环，导致系统崩溃;

### 迭代器模式
### 迭代器模式的定义

迭代器模式(Iterator Pattern) 又称为游标模式(Cursor Pattern 它提供种顺序访问集 合/容器对象元素的方法， 而又无须暴露 集合部表示。

本质:抽离集合对象迭代行为到迭代器中，提供一致访问接口。
属于行为型模式。

### 迭代器模式的适用场景

1、访问一个集合对象的内容而无需暴露它的内部表示
2、为遍历不同的集合结构提供个统一 的访问接口

### 迭代器模式的优点
1、多态迭代:为不同的聚合结构提供一致的遍历接口，即一个迭代接 口可以访问不同的聚集对象;
2、简化集合对象接口:迭代器模式将集合对象本身应该提供的元素迭 代接口抽取到了迭代器中，使集合对象无须关心具体迭代行为;
3、元素迭代功能多样化:每个集合对象都可以提供个或 多个不同的 迭代器，使的同种元素聚合结构可以有不同的迭代行为;
4、解耦迭代与集合:迭代器模式封装了具体的迭代算法，迭代算法 的变化，不会影响到集合对象的架构。

### 迭代器模式的缺点

1、对于比较简单的遍历(像数组或者有序列表)，使用迭代器方式遍历较为繁琐。
